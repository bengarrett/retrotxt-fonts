package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/user"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

const (
	// path to woff web fonts.
	fontDir = `github/RetroTxt-daily/ext/fonts`
	// path to the json font data store.
	dataFile = `github/RetroTxt-daily/ext/json/font_info.json`
	// output css filename.
	fnHTML = `fonts.html`
	// output html filename.
	fnCSS = `fonts.css`
)

// CSS rules.
type CSS struct {
	FontFamily string
	ID         string
	Size       string // font size in pixel or em
}

func (c CSS) String() (string, error) {
	buf := &bytes.Buffer{}
	t, err := template.New("css").Parse(cssTpl)
	if err != nil {
		return "", fmt.Errorf("input element: %w", err)
	}
	err = t.Execute(buf, c)
	if err != nil {
		return "", fmt.Errorf("input template: %w", err)
	}
	return buf.String(), nil
}

// Fonts from The Ultimate Oldschool PC Font Pack v2.0.
type Fonts struct {
	// autogenerated at https://mholt.github.io/json-to-go
	FontInfo []struct {
		Index          int    `json:"index"`
		WebSafeName    string `json:"web_safe_name"`
		HasPlus        bool   `json:"has_plus"`
		BaseName       string `json:"base_name"`
		HasAspect      bool   `json:"has_aspect"`
		SqAspect       string `json:"sq_aspect"`
		AcAspect       string `json:"ac_aspect"`
		OrigW          int    `json:"orig_w"`
		OrigH          int    `json:"orig_h"`
		FonWoffSzPx    int    `json:"fon_woff_sz_px"`
		TtfSzPx        int    `json:"ttf_sz_px"`
		TtfSzPt        int    `json:"ttf_sz_pt"`
		InfotxtOrigins string `json:"infotxt_origins"`
		InfotxtUsage   string `json:"infotxt_usage"`
	} `json:"font_info"`
}

// Header for groups of similar fonts.
type Header struct {
	Origin string
	Usage  string
}

func (h Header) String() (string, error) {
	buf := &bytes.Buffer{}
	t, err := template.New("header").Parse(hTpl)
	if err != nil {
		return "", fmt.Errorf("header element: %w", err)
	}
	err = t.Execute(buf, h)
	if err != nil {
		return "", fmt.Errorf("header template: %w", err)
	}
	return buf.String(), nil
}

// Radio HTML element values.
type Radio struct {
	Name       string // form name that should be the shared for all radio input elements
	ID         string // unique ID used for JS and CSS assignments
	FontFamily string // assigned CSS font-family value
	For        string // label for and input id
	Label      string // the font title displayed to the end user
	Underline  bool   // underline the font label
}

func (r Radio) String() (string, error) {
	buf := &bytes.Buffer{}
	t, err := template.New("webpage").Parse(radioTpl)
	if err != nil {
		return "", fmt.Errorf("input element: %w", err)
	}
	err = t.Execute(buf, r)
	if err != nil {
		return "", fmt.Errorf("input template: %w", err)
	}
	return buf.String(), nil
}

// css rule template.
const cssTpl = `@font-face {
  font-family: "{{.ID}}";
  src: url("../fonts/{{.FontFamily}}.woff") format("woff");
  font-display: swap;
}
.font-{{.ID}} {
  font-family: {{.ID}};
  font-size: {{.Size}};
  line-height: {{.Size}};
}`

// radio input template.
const radioTpl = `<label for="{{.For}}">
  <input type="radio" name="{{.Name}}" id="{{.For}}" value="{{.ID}}"> {{if .Underline}}<u>{{.Label}}</u>{{else}}{{.Label}}{{end}}
</label>`

// header template.
const hTpl = `<h2 class="title has-text-dark is-size-6 mt-4{{if not .Usage}} mb-2{{end}}">{{.Origin}}</h2>{{if .Usage}}
<h3 class="subtitle has-text-dark is-size-7 mb-2">{{.Usage}}</h3>{{end}}`

func main() {
	var (
		css   bytes.Buffer
		html  bytes.Buffer
		fonts Fonts
		h     string
	)
	usr, err := user.Current()
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	raw, err := ioutil.ReadFile(filepath.Join(usr.HomeDir, dataFile))
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	if err = json.Unmarshal(raw, &fonts); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	now := time.Now().UTC().Format(time.RFC822Z)
	const start, msdos, video, semi = 0, 59, 130, 184
	const h1, h10, hr = `<h1 class="title is-size-4 has-text-light mb-0">`, `</h1>`, `<hr>`
	const info = `<p class="is-size-7">Fonts support the IBM PC original 256 character encoding (codepage 437); <u>marked</u> fonts expands support to some 780 characters</p>`
	fmt.Fprintf(&html, "<!-- automatic generation begin (%s) -->\n<div>\n", now)
	for i := range fonts.FontInfo {
		f := &fonts.FontInfo[i]
		n := f.WebSafeName
		if variant(n) {
			continue
		}
		switch f.Index {
		case start:
			fmt.Fprintln(&html, hr+h1+"IBM PC &amp; family"+h10)
			fmt.Fprintln(&html, info)
		case msdos:
			fmt.Fprintln(&html, hr+h1+"MS-DOS compatibles"+h10)
			fmt.Fprintln(&html, info)
		case video:
			fmt.Fprintln(&html, hr+h1+"Video hardware"+h10)
			fmt.Fprintln(&html, info)
		case semi:
			fmt.Fprintln(&html, hr+h1+"Semi-compatibles"+h10)
			fmt.Fprintln(&html, info)
		}
		if f.InfotxtOrigins != h {
			head := Header{
				Origin: title(f.InfotxtOrigins),
				Usage:  f.InfotxtUsage,
			}
			s, err := head.String()
			if err != nil {
				fmt.Println(err.Error())
				os.Exit(1)
			}
			h = f.InfotxtOrigins
			fmt.Fprintln(&html, s)
		}
		ff := fontFamily(f.BaseName)
		filename := filepath.Join(usr.HomeDir, fontDir, fmt.Sprintf("%s.woff", ff))
		if _, err := os.Stat(filename); os.IsNotExist(err) {
			fmt.Println("! Font file not found:", ff)
			fmt.Println(n)
			continue
		}
		r := Radio{
			Name:       "font",
			ID:         f.WebSafeName,
			FontFamily: ff,
			For:        strings.ToLower(ff),
			Label:      f.BaseName,
			Underline:  f.HasPlus,
		}
		s, err := r.String()
		if err != nil {
			fmt.Println(err.Error())
			os.Exit(1)
		}
		fmt.Fprintln(&html, s)
	}
	fmt.Fprintf(&html, "</div>\n<!-- automatic generation end (%s) -->\n", now)
	if err := save(&html, fnHTML); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	for i := range fonts.FontInfo {
		f := &fonts.FontInfo[i]
		n := f.WebSafeName
		if variant(n) {
			continue
		}
		c := CSS{
			ID:         f.WebSafeName,
			FontFamily: fontFamily(f.BaseName),
			Size:       fmt.Sprintf("%dpx", f.FonWoffSzPx),
		}
		s, err := c.String()
		if err != nil {
			fmt.Println(err.Error())
			os.Exit(1)
		}
		fmt.Fprintln(&css, s)
	}
	if err := save(&css, fnCSS); err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}

func fontFamily(b string) string {
	s := strings.ReplaceAll(b, " ", "_")
	s = strings.ReplaceAll(s, "/", "-")
	s = strings.ReplaceAll(s, "_re.", "_re")
	s = strings.ReplaceAll(s, "_:", "_")
	s = strings.ReplaceAll(s, "AT&T", "ATT")
	return fmt.Sprintf("Web_%s", s)
}

func save(b io.WriterTo, name string) error {
	f, err := os.Create(name)
	if err != nil {
		return fmt.Errorf("save create %q: %w", name, err)
	}
	w := bufio.NewWriter(f)
	_, err = b.WriteTo(w)
	if err != nil {
		return fmt.Errorf("save write to %q: %w", name, err)
	}
	return nil
}

func title(n string) string {
	const (
		span = "<span class=\"has-text-weight-normal\">"
		cls  = "</span>"
	)
	s := n
	if strings.ContainsAny(s, "(") {
		s = strings.Replace(s, "(", span+"(", 1)
		s += cls
	} else if strings.Contains(s, "Multimode Graphics Adapter") {
		s = strings.Replace(s, "Multimode Graphics Adapter", span+"Multimode Graphics Adapter", 1)
		s += cls
	}
	s = strings.ReplaceAll(s, "incl.", "includes")
	s = strings.Replace(s, "Adapter Interface drivers for", span+"Adapter Interface drivers for"+cls, 1)
	s = strings.Replace(s, "series video BIOS", span+"series video BIOS"+cls, 1)
	s = strings.Replace(s, "on-board video", span+"on-board video"+cls, 1)
	s = strings.Replace(s, "system font", span+"system font"+cls, 1)
	s = strings.Replace(s, "system-loaded font", span+"system-loaded font"+cls, 1)
	s = strings.Replace(s, "firmware and system", span+"firmware and system"+cls, 1)
	return s
}

func variant(n string) bool {
	const tail = 3
	var end = ""
	if len(n) > tail {
		end = n[len(n)-tail:]
	}
	switch end {
	case "-2x", "-2y":
		return true
	}
	return false
}
